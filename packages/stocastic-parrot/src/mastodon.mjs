import generator from 'megalodon';
import { from } from 'rxjs';
import { concatMap, map, delay, scan } from 'rxjs/operators';
import { createReadStream } from 'node:fs';

const debugMode = process.env.DEBUG_MODE === 'true';
const CHAT_TOOT_HASHTAGS = '#StochasticParrot #ChatGPT';
const IMAGE_TOOT_HASHTAGS = '#StochasticParrot #DallE';

/**
 * Function that splits up a large piece of text down into arrays of text
 * no more than 500 characters long. This is required for Mastodon.
 * @param {string} messageToToot
 * @returns {string[]} Array of strings to toot
 */
function splitToots(messageToToot) {
  const toots = [];
  const maxLen = toots.length > 0 ? 500 : 470;

  while (messageToToot.length > 0) {
    let status = '';
    let inCodeBlock = false;
    if (messageToToot.length >= maxLen) {
      const parts = messageToToot.split(' ');
      for (let i = 0; i < parts.length; i++) {
        if (parts[i] === '```' && !inCodeBlock) {
          inCodeBlock = !inCodeBlock;
          break
        } 
        if (status.length + parts[i].length >= maxLen) {
          break;
        }
        status = `${status} ${parts[i]}`;
      }
      messageToToot = messageToToot.substring(status.length);
      if (toots.length === 0) {
        status = `${status}\n\n${CHAT_TOOT_HASHTAGS}`;
      }
    } else {
      status = `${messageToToot}`;
      if (toots.length === 0) {
        status = `${status}\n\n${CHAT_TOOT_HASHTAGS}`;
      }
      messageToToot = '';
    }
    toots.push(status.trim());
  }
  return toots;
}

/**
 * Create a Mastodon client
 * @param {*} accessToken
 * @param {*} site
 * @returns
 */
export function createMastodonClient(
  accessToken,
  site = 'https://mastodon.social'
) {
  const mastodon = generator.default('mastodon', site, accessToken);

  function sendToots(postMessage) {
    let messageParts = splitToots(postMessage);
    let firstTootUrl = '';
    let lastTootId = '';

    return from(messageParts).pipe(
      concatMap((status) => {
        const options = { status, visibility: 'public' };
        if (lastTootId) {
          options.in_reply_to_id = lastTootId;
        }
        return from(mastodon.postStatus(status, options)).pipe(
          map((res) => res.data),
          map((data) => {
            if (!firstTootUrl) {
              firstTootUrl = data.url;
            }
            lastTootId = data.id;
            return firstTootUrl;
          }),
          delay(100)
        );
      })
    );
  }

  /**
   *
   * @param {*} filePath
   * @param {*} withPrompt
   * @returns
   */
  async function postMedia(filePath, withPrompt = false) {
    const media = await mastodon.uploadMedia(createReadStream(filePath), {
      description: 'An image generated by ChatGPT with no prompt',
    });
    const status = withPrompt ? `ðŸ’¬` : `ðŸ¦œ`;
    const result = await mastodon.postStatus(
      `${status} ${IMAGE_TOOT_HASHTAGS}`,
      {
        media_ids: [media.data.id],
        visibility: 'public',
      }
    );
    return result.data.url;
  }

  return {
    postMedia,
    sendToots,
  };
}
