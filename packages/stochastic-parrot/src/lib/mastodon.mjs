import generator from 'megalodon';
import { createReadStream } from 'node:fs';
import { from } from 'rxjs';
import {
  concatMap,
  map,
  mergeScan,
  scan,
  switchMap,
  tap,
} from 'rxjs/operators';
import textract from 'textract';
import { retryConfig } from '../config.mjs';
import { errorHandlerWithDelay } from './lib.mjs';

const debugMode = process.env.DEBUG_MODE === 'true';
const CHAT_TOOT_HASHTAGS = '#StochasticParrot #ChatGPT';
const MEDIA_TOOT_HASHTAGS = '#StochasticParrot #ChatGPT #AIArt #AIArtwork';
const POLL_TOOT_HASHTAGS = '#StochasticParrot #ChatGPT #Poll';

/**
 * Function that splits up a large piece of text down into arrays of text
 * no more than 500 characters long. If the code encounters a code block, it will
 * stop the current toot and start a new one with the code block, if this is more than
 * 500 characters long, it should close the code block and start a new toot starting with
 * a new code block until the end of the content code block.
 * This is required for Mastodon.
 * @param {string} messageToToot
 * @param {boolean} withMedia
 * @returns {string[]} Array of strings to toot
 */
function splitToots(messageToToot, withMedia = false, withPoll = false) {
  const toots = [];
  const maxLen = toots.length > 0 ? 500 : 470;
  const hashtags = withMedia
    ? MEDIA_TOOT_HASHTAGS
    : withPoll
    ? POLL_TOOT_HASHTAGS
    : CHAT_TOOT_HASHTAGS;

  while (messageToToot.length > 0) {
    let status = '';
    let inCodeBlock = false;

    if (messageToToot.length >= maxLen) {
      const parts = messageToToot.split(' ');
      for (let i = 0; i < parts.length; i++) {
        if (parts[i] === '```' && !inCodeBlock) {
          inCodeBlock = true;
        } else if (parts[i] === '```' && inCodeBlock) {
          inCodeBlock = false;
        }
        if (status.length + parts[i].length >= maxLen) {
          break;
        }
        status = `${status} ${parts[i]}`;
      }
      messageToToot = messageToToot.substring(status.length);

      if (toots.length === 0) {
        status = `${status}\n\n${hashtags}`;
      }
    } else {
      status = `${messageToToot}`;
      if (toots.length === 0) {
        status = `${status}\n\n${hashtags}`;
      }
      messageToToot = '';
    }
    toots.push(status.trim());
  }
  return toots;
}

/**
 * Create a Mastodon client
 * @param {*} accessToken
 * @param {*} site
 * @returns
 */
export function createMastodonClient(
  accessToken,
  site = 'https://botsin.space'
) {

  /**
   * @type {import('megalodon').Mastodon}
   */
  const mastodon = generator.default('mastodon', site, accessToken);

  /**
   * Posts a message to Mastodon, splitting it up into multiple toots if necessary.
   * You can also pass in an array of media IDs to attach to the first toot.
   *
   * @param {string} postMessage The request body of the toot
   * @param {object} options Optional options
   * @returns
   */
  function sendToots(postMessage, { media_ids, poll } = {}) {
    let messageParts = splitToots(
      postMessage,
      media_ids && media_ids.length > 0,
      !!poll
    );
    let firstTootUrl = '';
    let lastTootId = '';

    return from(messageParts)
      .pipe(
        concatMap((status) => {
          const options = {
            status,
            visibility: 'public',
            ...(lastTootId && { in_reply_to_id: lastTootId }),
            ...(media_ids &&
              media_ids.length > 0 &&
              !lastTootId && { media_ids }),
            ...(poll && !lastTootId && { poll }),
          };
          return from(mastodon.postStatus(status, options)).pipe(
            map((res) => res.data),
            tap((data) => {
              if (!firstTootUrl) {
                firstTootUrl = data.url;
              }
              lastTootId = data.id;
            }),
            errorHandlerWithDelay(retryConfig),
            map(() => firstTootUrl),
          );
        })
      )
      .pipe(mergeScan((acc, tootUrl) => [...new Set([...acc, tootUrl])], []));
  }

  /**
   * Upload an image to Mastodon and return the media ID
   * @param {string} filePath
   * @param {string=} description
   * @returns
   */
  function postMedia(
    filePath,
    description = 'An file generated by ChatGPT with no prompt'
  ) {
    return from(
      mastodon.uploadMedia(createReadStream(filePath), {
        description,
      })
    ).pipe(
      errorHandlerWithDelay(retryConfig),
      map((res) => res?.data?.id ?? ''),
    );
  }

  /**
   * Returns one or more toots from the local timeline, and returns the parsed text
   * removing the HTML
   * @param {number} limit The number of toots to return
   * @returns
   */
  function getLocalTimeline(limit = 1) {
    return from(mastodon.getLocalTimeline({ limit })).pipe(
      errorHandlerWithDelay(retryConfig),
      switchMap((res) => from(res.data)),
      concatMap((toot) =>
        from(
          new Promise((resolve) =>
            textract.fromBufferWithMime(
              'text/html',
              Buffer.from(toot.content),
              (err, data) => resolve(data)
            )
          )
        ).pipe(scan((acc, data) => [...acc, data], []))
      )
    );
  }

  /**
   * Get an Mastadon toot by it's ID
   * @param {string} id The ID of the toot
   * @returns {object} A Mastodon toot
   */
  function getStatus(id) {
    return from(mastodon.getStatus(id)).pipe(
      errorHandlerWithDelay(retryConfig),
      map((res) => res.data),
    );
  }

  return {
    postMedia,
    sendToots,
    getLocalTimeline,
    getStatus,
    client: mastodon,
  };
}
